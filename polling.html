<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VoteHub Polls Dashboard (Selected Pollsters)</title>

  <!-- Plotly for charts -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; line-height: 1.35; }
    header { padding: 18px 16px; border-bottom: 1px solid rgba(127,127,127,0.35); }
    header h1 { margin: 0 0 6px 0; font-size: 18px; font-weight: 650; }
    header .meta { font-size: 12px; opacity: 0.85; }
    main { padding: 14px 16px 24px; max-width: 1100px; margin: 0 auto; }
    .card { border: 1px solid rgba(127,127,127,0.35); border-radius: 12px; padding: 12px; margin: 12px 0; }
    .card h2 { margin: 0 0 6px 0; font-size: 15px; }
    #status { font-size: 12px; opacity: 0.92; margin-bottom: 10px; white-space: pre-wrap; }
    .plot { width: 100%; height: 520px; }
    .small { font-size: 12px; opacity: 0.85; white-space: pre-wrap; }
    code.inline { padding: 1px 6px; border: 1px solid rgba(127,127,127,0.35); border-radius: 6px; font-size: 12px; }
    #debugCard { display: none; }
  </style>
</head>

<body>
  <header>
    <h1>Polling Dashboard (restricted pollster list)</h1>
    <div class="meta">
      VoteHub API + rolling averages. Debug: <code class="inline">?debug=1</code>
    </div>
  </header>

  <main>
    <div id="status">Booting…</div>

    <div class="card">
      <h2>Trump Approval (scatter + 14-day rolling average)</h2>
      <div id="approvalChart" class="plot"></div>
      <div id="approvalNote" class="small"></div>
    </div>

    <div class="card">
      <h2>Generic Ballot (Dem − Rep margin; scatter + 30-day rolling average)</h2>
      <div id="gbChart" class="plot"></div>
      <div id="gbNote" class="small"></div>
    </div>

    <div class="card">
      <h2>Included pollsters</h2>
      <div class="small" id="pollsterList"></div>
    </div>

    <div class="card" id="debugCard">
      <h2>Debug</h2>
      <div class="small" id="debugOut"></div>
    </div>
  </main>

<script>
/* -------------------- CONFIG -------------------- */

const API_BASE = "https://api.votehub.com/polls";

// If direct browser fetch is blocked by CORS, we try these public CORS proxies.
// Disable proxies with ?proxy=0
const PROXY_TEMPLATES = (new URLSearchParams(location.search).get("proxy") === "0")
  ? [
      { name: "direct", make: (url) => url },
    ]
  : [
      { name: "direct",     make: (url) => url },
      { name: "allorigins", make: (url) => "https://api.allorigins.win/raw?url=" + encodeURIComponent(url) },
      { name: "corsproxy",  make: (url) => "https://corsproxy.io/?" + encodeURIComponent(url) },
      { name: "codetabs",   make: (url) => "https://api.codetabs.com/v1/proxy?quest=" + encodeURIComponent(url) },
    ];

const DEBUG = new URLSearchParams(location.search).has("debug");

const APPROVAL_WINDOW_DAYS = 14;
const GB_WINDOW_DAYS = 30;
const LOOKBACK_DAYS = 400;

// Subjects to try (VoteHub accepts dashes/spaces; we try a few to avoid “0 polls” from slug mismatch)
const APPROVAL_SUBJECT_CANDIDATES = [
  "donald-trump",
  "donald trump",
  "Donald Trump",
  "trump",
];

// Your pollster allowlist. Implemented as robust string patterns.
const ALLOWED_POLLSTERS = [
  { label: "YouGov", pattern: /yougov/ },
  { label: "Ipsos", pattern: /ipsos/ },
  { label: "American Research Group", pattern: /americanresearchgroup|arg\b/ },
  { label: "TIPP Insights", pattern: /tipp/ },
  { label: "Emerson College", pattern: /emerson/ },
  { label: "Gallup", pattern: /gallup/ },
  { label: "Marist College", pattern: /marist/ },
  { label: "Quinnipiac University", pattern: /quinnipiac/ },
  { label: "AP-NORC", pattern: /apnorc|ap\-norc|norc/ },
  { label: "Marquette University Law School", pattern: /marquette/ },
  { label: "CNN/SSRS", pattern: /cnnssrs|cnn\/ssrs|ssrs/ },
  { label: "AtlasIntel", pattern: /atlasintel|atlas/ },
  { label: "Beacon Research/Shaw & Co. Research", pattern: /beaconresearch|shaw/ },
  { label: "Hart Research Associates/Public Opinion Strategies", pattern: /hartresearch|publicopinionstrategies/ },
  { label: "Verasight", pattern: /verasight/ },
  { label: "Pew Research Center", pattern: /pewresearch|pew/ },
  { label: "SurveyMonkey", pattern: /surveymonkey/ },
  { label: "The Argument/Verasight", pattern: /theargument/ },
  { label: "Leger", pattern: /leger/ },
  { label: "University of Massachusetts Dept. of Political Science/YouGov", pattern: /massachusetts|umass|departmentofpoliticalscience/ }
];

/* -------------------- UI HELPERS -------------------- */

const debugCard = document.getElementById("debugCard");
const debugOut  = document.getElementById("debugOut");
if (DEBUG) debugCard.style.display = "block";

function setStatus(msg) {
  document.getElementById("status").textContent = msg;
}

function logDebug(msg) {
  if (!DEBUG) return;
  debugOut.textContent += (debugOut.textContent ? "\n" : "") + String(msg);
}

window.addEventListener("error", (e) => {
  setStatus(`Runtime error: ${e.message || e.type}\nOpen with ?debug=1`);
  logDebug(`window.error: ${e.message}\n${e.filename}:${e.lineno}:${e.colno}`);
});

window.addEventListener("unhandledrejection", (e) => {
  const msg = (e && e.reason && e.reason.message) ? e.reason.message : String(e.reason || e);
  setStatus(`Unhandled promise rejection: ${msg}\nOpen with ?debug=1`);
  logDebug(`unhandledrejection: ${msg}`);
});

/* -------------------- DATA / MATH HELPERS -------------------- */

function ensurePlotly() {
  if (!window.Plotly || typeof Plotly.newPlot !== "function") {
    throw new Error("Plotly failed to load (CDN blocked?).");
  }
}

function norm(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/&/g, "and")
    .replace(/[^a-z0-9]+/g, "");
}

function isAllowedPollster(pollsterName) {
  const n = norm(pollsterName);
  return ALLOWED_POLLSTERS.some(x => x.pattern.test(n));
}

function parseDateYYYYMMDD(s) {
  return new Date(`${s}T00:00:00Z`);
}

function fmtDate(d) {
  return d.toISOString().slice(0, 10);
}

function rollingMeanDaily(points, windowDays) {
  if (!points.length) return [];
  const msDay = 24 * 60 * 60 * 1000;
  const windowMs = windowDays * msDay;

  const pts = points.slice().sort((a, b) => a.date - b.date);

  const minD = new Date(Date.UTC(
    pts[0].date.getUTCFullYear(),
    pts[0].date.getUTCMonth(),
    pts[0].date.getUTCDate()
  ));
  const maxD = new Date(Date.UTC(
    pts[pts.length - 1].date.getUTCFullYear(),
    pts[pts.length - 1].date.getUTCMonth(),
    pts[pts.length - 1].date.getUTCDate()
  ));

  let i = 0, j = 0, sum = 0;
  const out = [];

  for (let t = minD.getTime(); t <= maxD.getTime(); t += msDay) {
    const day = new Date(t);

    while (j < pts.length && pts[j].date.getTime() <= day.getTime()) {
      sum += pts[j].value; j++;
    }

    const threshold = day.getTime() - windowMs;
    while (i < j && pts[i].date.getTime() <= threshold) {
      sum -= pts[i].value; i++;
    }

    const n = j - i;
    if (n > 0) out.push({ date: day, value: sum / n, n });
  }

  return out;
}

function buildPollsterCounts(points) {
  const counts = new Map();
  for (const p of points) {
    const k = p.pollster || "Unknown";
    counts.set(k, (counts.get(k) || 0) + 1);
  }
  return [...counts.entries()].sort((a,b) => b[1] - a[1]);
}

// Match answer labels loosely
function choiceMatches(choice, wanted) {
  const c = norm(choice);
  const w = norm(wanted);
  return c === w || c.includes(w) || w.includes(c);
}

function getAnswerPct(poll, wantedChoices) {
  const answers = Array.isArray(poll.answers) ? poll.answers : [];
  for (const a of answers) {
    for (const w of wantedChoices) {
      if (choiceMatches(a.choice, w)) return Number(a.pct);
    }
  }
  return null;
}

function parseJsonRobust(text) {
  // Prefer direct parse
  try { return JSON.parse(text); } catch (_) {}

  // Some proxies prepend junk; try slicing to the first JSON bracket/brace.
  const firstBrace = text.indexOf("{");
  const firstBracket = text.indexOf("[");
  let start = -1, end = -1;

  if (firstBracket !== -1 && (firstBrace === -1 || firstBracket < firstBrace)) {
    start = firstBracket;
    end = text.lastIndexOf("]");
  } else if (firstBrace !== -1) {
    start = firstBrace;
    end = text.lastIndexOf("}");
  }

  if (start !== -1 && end !== -1 && end > start) {
    return JSON.parse(text.slice(start, end + 1));
  }

  throw new Error("Could not parse JSON from response text.");
}

function extractPollArray(json) {
  // VoteHub docs show { polls: [...] }
  if (json && Array.isArray(json.polls)) return json.polls;

  // Some APIs nest in "data"
  if (json && json.data && Array.isArray(json.data.polls)) return json.data.polls;

  // Some endpoints might return a raw array
  if (Array.isArray(json)) return json;

  return null;
}

/* -------------------- FETCHING -------------------- */

async function fetchTextWithTimeout(url, timeoutMs = 20000) {
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);
  try {
    const res = await fetch(url, {
      headers: { "Accept": "application/json" },
      cache: "no-store",
      signal: ctrl.signal
    });
    const ct = res.headers.get("content-type") || "";
    const text = await res.text();
    return { res, ct, text };
  } finally {
    clearTimeout(t);
  }
}

function looksLikeProxyError(json) {
  // Handle the specific “proxy wrapper” style errors (like the one you pasted).
  // Example keys: code, status, data, meta; data.warning mentions target URL error
  if (!json || typeof json !== "object") return false;
  if (!("code" in json) || !("data" in json)) return false;
  const d = json.data;
  if (d && typeof d === "object" && typeof d.warning === "string" && d.warning.toLowerCase().includes("target url returned error")) {
    return true;
  }
  return false;
}

async function fetchPollsSmart(paramsObj) {
  // paramsObj is a plain object; we build a query string once.
  const qs = new URLSearchParams(paramsObj).toString();
  const targetUrl = `${API_BASE}?${qs}`;

  let lastDiag = null;

  for (const tpl of PROXY_TEMPLATES) {
    const attemptUrl = tpl.make(targetUrl);

    try {
      const { res, ct, text } = await fetchTextWithTimeout(attemptUrl);

      // CORS failures will usually throw before here; non-OK still gives us payload.
      if (!res.ok) {
        lastDiag = `HTTP ${res.status} via ${tpl.name}\nurl=${attemptUrl}\ncontent-type=${ct}\nbody(head)=${text.slice(0, 240)}`;
        logDebug(lastDiag);
        continue;
      }

      const json = parseJsonRobust(text);

      if (looksLikeProxyError(json)) {
        lastDiag = `Proxy wrapper error via ${tpl.name}\nurl=${attemptUrl}\nbody(head)=${text.slice(0, 240)}`;
        logDebug(lastDiag);
        continue;
      }

      const polls = extractPollArray(json);
      if (!polls) {
        const keys = (json && typeof json === "object") ? Object.keys(json).slice(0, 25).join(", ") : "(not an object)";
        lastDiag = `Unexpected JSON shape via ${tpl.name}\nurl=${attemptUrl}\nkeys=${keys}\nbody(head)=${text.slice(0, 240)}`;
        logDebug(lastDiag);
        continue;
      }

      logDebug(`FETCH OK via ${tpl.name}: items=${polls.length}`);
      return { polls, via: tpl.name, url: attemptUrl };
    } catch (e) {
      lastDiag = `Fetch/parse error via ${tpl.name}\nurl=${attemptUrl}\nerr=${e && e.message ? e.message : String(e)}`;
      logDebug(lastDiag);
      continue;
    }
  }

  throw new Error(lastDiag || "Failed to fetch polls (no diagnostic).");
}

/* -------------------- RENDERING -------------------- */

function renderPollsterList() {
  document.getElementById("pollsterList").textContent =
    ALLOWED_POLLSTERS.map(x => `• ${x.label}`).join("\n");
}

function renderApproval(points, maSeries, meta) {
  ensurePlotly();

  const hoverText = points.map(p =>
    `${p.pollster}<br>${fmtDate(p.date)}<br>Approve: ${p.approve.toFixed(1)}%` +
    (p.disapprove != null ? `<br>Disapprove: ${p.disapprove.toFixed(1)}%` : "") +
    (p.sample_size ? `<br>n=${p.sample_size}` : "") +
    (p.url ? `<br><a href="${p.url}" target="_blank" rel="noopener">source</a>` : "")
  );

  const tracePolls = {
    type: "scatter",
    mode: "markers",
    name: "Polls (Approve %)",
    x: points.map(p => p.date),
    y: points.map(p => p.value),
    text: hoverText,
    hovertemplate: "%{text}<extra></extra>",
    marker: { size: 9 }
  };

  const traceMA = {
    type: "scatter",
    mode: "lines",
    name: `${APPROVAL_WINDOW_DAYS}-day rolling avg`,
    x: maSeries.map(d => d.date),
    y: maSeries.map(d => d.value),
    hovertemplate: "%{x|%Y-%m-%d}<br>Avg: %{y:.2f}%<br>Polls in window: %{customdata}<extra></extra>",
    customdata: maSeries.map(d => d.n),
    line: { width: 3 }
  };

  Plotly.newPlot("approvalChart", [traceMA, tracePolls], {
    margin: { l: 55, r: 18, t: 10, b: 50 },
    xaxis: { title: "Poll end date", type: "date" },
    yaxis: { title: "Approve (%)", rangemode: "tozero" },
    legend: { orientation: "h", y: 1.05, x: 0 },
    hovermode: "closest"
  }, { responsive: true, displayModeBar: false });

  const lastMA = maSeries.length ? maSeries[maSeries.length - 1] : null;
  document.getElementById("approvalNote").textContent = [
    `Included polls: ${meta.totalIncluded} (from ${meta.totalFetched} fetched).`,
    lastMA ? `Latest ${APPROVAL_WINDOW_DAYS}-day avg (as of ${fmtDate(lastMA.date)}): ${lastMA.value.toFixed(2)}% (window polls: ${lastMA.n}).`
           : `Not enough data for rolling average.`,
    meta.byPollster.length ? `Top pollsters by count: ${meta.byPollster.slice(0, 6).map(([k,v]) => `${k} (${v})`).join(", ")}.` : ""
  ].filter(Boolean).join(" ");
}

function renderGenericBallot(points, maSeries, meta) {
  ensurePlotly();

  const hoverText = points.map(p =>
    `${p.pollster}<br>${fmtDate(p.date)}<br>Dem: ${p.dem.toFixed(1)}%<br>Rep: ${p.rep.toFixed(1)}%` +
    `<br>Margin (D−R): ${p.value.toFixed(1)}` +
    (p.sample_size ? `<br>n=${p.sample_size}` : "") +
    (p.url ? `<br><a href="${p.url}" target="_blank" rel="noopener">source</a>` : "")
  );

  const tracePolls = {
    type: "scatter",
    mode: "markers",
    name: "Polls (D−R)",
    x: points.map(p => p.date),
    y: points.map(p => p.value),
    text: hoverText,
    hovertemplate: "%{text}<extra></extra>",
    marker: { size: 9 }
  };

  const traceMA = {
    type: "scatter",
    mode: "lines",
    name: `${GB_WINDOW_DAYS}-day rolling avg`,
    x: maSeries.map(d => d.date),
    y: maSeries.map(d => d.value),
    hovertemplate: "%{x|%Y-%m-%d}<br>Avg margin: %{y:.2f}<br>Polls in window: %{customdata}<extra></extra>",
    customdata: maSeries.map(d => d.n),
    line: { width: 3 }
  };

  Plotly.newPlot("gbChart", [traceMA, tracePolls], {
    margin: { l: 70, r: 18, t: 10, b: 50 },
    xaxis: { title: "Poll end date", type: "date" },
    yaxis: { title: "Generic ballot margin (Dem − Rep)", zeroline: true },
    shapes: [{
      type: "line", xref: "paper", x0: 0, x1: 1,
      yref: "y", y0: 0, y1: 0,
      line: { width: 1, dash: "dot" }
    }],
    legend: { orientation: "h", y: 1.05, x: 0 },
    hovermode: "closest"
  }, { responsive: true, displayModeBar: false });

  const lastMA = maSeries.length ? maSeries[maSeries.length - 1] : null;
  document.getElementById("gbNote").textContent = [
    `Included polls: ${meta.totalIncluded} (from ${meta.totalFetched} fetched).`,
    lastMA ? `Latest ${GB_WINDOW_DAYS}-day avg (as of ${fmtDate(lastMA.date)}): ${lastMA.value.toFixed(2)} pts (window polls: ${lastMA.n}).`
           : `Not enough data for rolling average.`,
    meta.byPollster.length ? `Top pollsters by count: ${meta.byPollster.slice(0, 6).map(([k,v]) => `${k} (${v})`).join(", ")}.` : ""
  ].filter(Boolean).join(" ");
}

/* -------------------- MAIN -------------------- */

async function main() {
  renderPollsterList();

  const now = new Date();
  const from = new Date(now.getTime() - LOOKBACK_DAYS * 24 * 60 * 60 * 1000);
  const fromISO = from.toISOString().slice(0, 10);

  setStatus(
`Loading…
Lookback: ${LOOKBACK_DAYS} days (from ${fromISO})
Proxy attempts: ${PROXY_TEMPLATES.map(p => p.name).join(", ")}`
  );

  // ---- Approval fetch (try subject candidates) ----
  let approvalRaw = [];
  let approvalVia = "(none)";
  let approvalUrlUsed = "(none)";
  let approvalSubjectUsed = "(none)";
  let approvalFetchTotal = 0;

  for (const subj of APPROVAL_SUBJECT_CANDIDATES) {
    const { polls, via, url } = await fetchPollsSmart({
      poll_type: "approval",
      subject: subj,
      from_date: fromISO
    });

    approvalFetchTotal = polls.length;
    approvalRaw = polls;
    approvalVia = via;
    approvalUrlUsed = url;
    approvalSubjectUsed = subj;

    // accept the first non-empty result, else keep trying
    if (polls.length > 0) break;
  }

  // ---- Generic ballot fetch ----
  const gbPack = await fetchPollsSmart({
    poll_type: "generic-ballot",
    from_date: fromISO
  });
  const gbRaw = gbPack.polls;
  const gbVia = gbPack.via;
  const gbUrlUsed = gbPack.url;

  logDebug(`Approval via=${approvalVia} subject=${approvalSubjectUsed} raw=${approvalRaw.length}`);
  logDebug(`Approval url=${approvalUrlUsed}`);
  logDebug(`GB via=${gbVia} raw=${gbRaw.length}`);
  logDebug(`GB url=${gbUrlUsed}`);

  // ---- Process approval ----
  const approvalFiltered = approvalRaw
    .filter(p => isAllowedPollster(p.pollster))
    .map(p => {
      const approve = getAnswerPct(p, ["Approve", "Approval", "Yes"]);
      const disapprove = getAnswerPct(p, ["Disapprove", "Disapproval", "No"]);
      const date = p.end_date ? parseDateYYYYMMDD(p.end_date) : null;

      if (!date || approve == null || !Number.isFinite(approve)) return null;

      return {
        date,
        value: Number(approve),
        approve: Number(approve),
        disapprove: (disapprove != null && Number.isFinite(disapprove)) ? Number(disapprove) : null,
        pollster: p.pollster || "Unknown",
        sample_size: p.sample_size || "",
        url: p.url || ""
      };
    })
    .filter(Boolean);

  const approvalMA = rollingMeanDaily(approvalFiltered, APPROVAL_WINDOW_DAYS);

  // ---- Process generic ballot ----
  const gbFiltered = gbRaw
    .filter(p => {
      // keep only the national generic entry if seat_name is present
      if (p.seat_name == null) return true;
      return String(p.seat_name).toLowerCase() === "generic";
    })
    .filter(p => isAllowedPollster(p.pollster))
    .map(p => {
      const dem = getAnswerPct(p, ["Dem", "Democrat", "Democratic", "Democratic Party"]);
      const rep = getAnswerPct(p, ["Rep", "Republican", "GOP", "Republican Party"]);
      const date = p.end_date ? parseDateYYYYMMDD(p.end_date) : null;

      if (!date || dem == null || rep == null || !Number.isFinite(dem) || !Number.isFinite(rep)) return null;

      return {
        date,
        value: Number(dem) - Number(rep),
        dem: Number(dem),
        rep: Number(rep),
        pollster: p.pollster || "Unknown",
        sample_size: p.sample_size || "",
        url: p.url || ""
      };
    })
    .filter(Boolean);

  const gbMA = rollingMeanDaily(gbFiltered, GB_WINDOW_DAYS);

  // ---- Render charts ----
  renderApproval(approvalFiltered, approvalMA, {
    totalFetched: approvalRaw.length,
    totalIncluded: approvalFiltered.length,
    byPollster: buildPollsterCounts(approvalFiltered)
  });

  renderGenericBallot(gbFiltered, gbMA, {
    totalFetched: gbRaw.length,
    totalIncluded: gbFiltered.length,
    byPollster: buildPollsterCounts(gbFiltered)
  });

  setStatus(
`Loaded.
Approval: fetched=${approvalRaw.length} via=${approvalVia} subject="${approvalSubjectUsed}"
Generic ballot: fetched=${gbRaw.length} via=${gbVia}
Included after pollster filter: approval=${approvalFiltered.length}, generic-ballot=${gbFiltered.length}
Last refresh: ${new Date().toLocaleString()}`
  );
}

main();
</script>
</body>
</html>
