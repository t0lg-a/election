<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VoteHub Polls Dashboard (Selected Pollsters)</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.35;
    }
    header {
      padding: 18px 16px;
      border-bottom: 1px solid rgba(127,127,127,0.35);
    }
    header h1 { margin: 0 0 6px 0; font-size: 18px; font-weight: 650; }
    header .meta { font-size: 12px; opacity: 0.8; }
    main { padding: 14px 16px 24px; max-width: 1100px; margin: 0 auto; }
    .card {
      border: 1px solid rgba(127,127,127,0.35);
      border-radius: 12px;
      padding: 12px;
      margin: 12px 0;
    }
    .card h2 { margin: 0 0 6px 0; font-size: 15px; }
    #status { font-size: 12px; opacity: 0.85; margin-bottom: 10px; white-space: pre-wrap; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .plot { width: 100%; height: 520px; }
    @media (min-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }
    code.inline {
      padding: 1px 5px;
      border: 1px solid rgba(127,127,127,0.35);
      border-radius: 6px;
      font-size: 12px;
    }
    .small { font-size: 12px; opacity: 0.85; }
  </style>
</head>

<body>
  <header>
    <h1>Polling Dashboard (restricted pollster list)</h1>
    <div class="meta">
      Data: VoteHub Polling API (<span class="small">CC BY 4.0 per their docs</span>). Rolling averages: 14d (approval), 30d (generic ballot).
    </div>
  </header>

  <main>
    <div id="status">Booting…</div>

    <div class="card">
      <h2>Trump Approval (scatter + 14-day rolling average)</h2>
      <div id="approvalChart" class="plot"></div>
      <div id="approvalNote" class="small"></div>
    </div>

    <div class="card">
      <h2>Generic Ballot (Dem − Rep margin; scatter + 30-day rolling average)</h2>
      <div id="gbChart" class="plot"></div>
      <div id="gbNote" class="small"></div>
    </div>

    <div class="card">
      <h2>Included pollsters</h2>
      <div class="small" id="pollsterList"></div>
    </div>
  </main>

<script>
/**
 * VoteHub API docs: https://votehub.com/polls/api/
 * Base endpoint: https://api.votehub.com/polls
 * Example: /polls?poll_type=approval&subject=donald-trump
 */

const API_BASE = "https://api.votehub.com/polls";

// Your allowed list, implemented as robust match patterns to survive small naming differences.
const ALLOWED_POLLSTERS = [
  { label: "YouGov", pattern: /yougov/ },
  { label: "Ipsos", pattern: /ipsos/ },
  { label: "American Research Group", pattern: /americanresearchgroup|arg\b/ },
  { label: "TIPP Insights", pattern: /tipp/ },
  { label: "Emerson College", pattern: /emerson/ },
  { label: "Gallup", pattern: /gallup/ },
  { label: "Marist College", pattern: /marist/ },
  { label: "Quinnipiac University", pattern: /quinnipiac/ },
  { label: "AP-NORC", pattern: /apnorc|ap\-norc|norc/ },
  { label: "Marquette University Law School", pattern: /marquette/ },
  { label: "CNN/SSRS", pattern: /cnnssrs|ssrs/ },
  { label: "AtlasIntel", pattern: /atlasintel|atlas/ },
  { label: "Beacon Research/Shaw & Co. Research", pattern: /beaconresearch|shaw|shawco/ },
  { label: "Hart Research Associates/Public Opinion Strategies", pattern: /hartresearch|publicopinionstrategies/ },
  { label: "Verasight", pattern: /verasight/ },
  { label: "Pew Research Center", pattern: /pewresearch|pew/ },
  { label: "SurveyMonkey", pattern: /surveymonkey/ },
  { label: "The Argument/Verasight", pattern: /theargument/ },
  { label: "Leger", pattern: /leger/ },
  { label: "UMass Dept. of Political Science/YouGov", pattern: /massachusetts|umass|departmentofpoliticalscience/ }
];

function norm(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/&/g, "and")
    .replace(/[^a-z0-9]+/g, "");
}

function isAllowedPollster(pollsterName) {
  const n = norm(pollsterName);
  return ALLOWED_POLLSTERS.some(x => x.pattern.test(n));
}

function parseDateYYYYMMDD(s) {
  // Force UTC midnight to avoid timezone weirdness.
  return new Date(`${s}T00:00:00Z`);
}

function fmtDate(d) {
  return d.toISOString().slice(0, 10);
}

function mean(arr) {
  if (!arr.length) return null;
  let s = 0;
  for (const x of arr) s += x;
  return s / arr.length;
}

/**
 * Time-based rolling mean on a daily grid.
 * points: [{ date: Date, value: number, ... }]
 * windowDays: integer window length in days
 * Returns: [{ date: Date, value: number, n: number }]
 */
function rollingMeanDaily(points, windowDays) {
  if (!points.length) return [];

  const msDay = 24 * 60 * 60 * 1000;
  const windowMs = windowDays * msDay;

  const pts = points
    .slice()
    .sort((a, b) => a.date - b.date);

  const minD = new Date(Date.UTC(pts[0].date.getUTCFullYear(), pts[0].date.getUTCMonth(), pts[0].date.getUTCDate()));
  const maxD = new Date(Date.UTC(pts[pts.length - 1].date.getUTCFullYear(), pts[pts.length - 1].date.getUTCMonth(), pts[pts.length - 1].date.getUTCDate()));

  let i = 0, j = 0;
  let sum = 0;

  const out = [];
  for (let t = minD.getTime(); t <= maxD.getTime(); t += msDay) {
    const day = new Date(t);

    // Add polls with date <= day
    while (j < pts.length && pts[j].date.getTime() <= day.getTime()) {
      sum += pts[j].value;
      j++;
    }

    // Remove polls with date <= day - window
    const threshold = day.getTime() - windowMs;
    while (i < j && pts[i].date.getTime() <= threshold) {
      sum -= pts[i].value;
      i++;
    }

    const n = j - i;
    if (n > 0) out.push({ date: day, value: sum / n, n });
  }
  return out;
}

function getAnswerPct(poll, wantedChoices) {
  // poll.answers: [{choice, pct}, ...]
  const answers = Array.isArray(poll.answers) ? poll.answers : [];
  for (const a of answers) {
    const c = norm(a.choice);
    for (const w of wantedChoices) {
      if (c === norm(w)) return Number(a.pct);
    }
  }
  return null;
}

async function fetchPolls(url) {
  const res = await fetch(url, { headers: { "Accept": "application/json" } });
  if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
  const data = await res.json();

  // VoteHub docs show {polls:[...]}, but the live endpoint currently returns [...].
  if (Array.isArray(data)) return data;
  if (data && Array.isArray(data.polls)) return data.polls;
  return [];
}

function buildPollsterCounts(polls) {
  const counts = new Map();
  for (const p of polls) {
    const k = p.pollster || "Unknown";
    counts.set(k, (counts.get(k) || 0) + 1);
  }
  return [...counts.entries()].sort((a,b) => b[1] - a[1]);
}

function setStatus(msg) {
  document.getElementById("status").textContent = msg;
}

function renderPollsterList() {
  const items = ALLOWED_POLLSTERS.map(x => `• ${x.label}`).join("\n");
  document.getElementById("pollsterList").textContent = items;
}

function renderApproval(points, maSeries, meta) {
  const scatterX = points.map(p => p.date);
  const scatterY = points.map(p => p.value);
  const hoverText = points.map(p =>
    `${p.pollster}<br>${fmtDate(p.date)}<br>Approve: ${p.approve.toFixed(1)}%` +
    (p.disapprove != null ? `<br>Disapprove: ${p.disapprove.toFixed(1)}%` : "") +
    (p.sample_size ? `<br>n=${p.sample_size}` : "") +
    (p.url ? `<br><a href="${p.url}" target="_blank" rel="noopener">source</a>` : "")
  );

  const tracePolls = {
    type: "scatter",
    mode: "markers",
    name: "Polls (Approve %)",
    x: scatterX,
    y: scatterY,
    text: hoverText,
    hovertemplate: "%{text}<extra></extra>",
    marker: { size: 9 }
  };

  const traceMA = {
    type: "scatter",
    mode: "lines",
    name: "14-day rolling avg",
    x: maSeries.map(d => d.date),
    y: maSeries.map(d => d.value),
    hovertemplate: "%{x|%Y-%m-%d}<br>Avg: %{y:.2f}%<br>Polls in window: %{customdata}<extra></extra>",
    customdata: maSeries.map(d => d.n),
    line: { width: 3 }
  };

  const layout = {
    margin: { l: 55, r: 18, t: 10, b: 50 },
    xaxis: { title: "Poll end date", type: "date" },
    yaxis: { title: "Approve (%)", rangemode: "tozero" },
    legend: { orientation: "h", y: 1.05, x: 0 },
    hovermode: "closest"
  };

  Plotly.newPlot("approvalChart", [traceMA, tracePolls], layout, { responsive: true, displayModeBar: false });

  const lastMA = maSeries.length ? maSeries[maSeries.length - 1] : null;
  const note = [
    `Included polls: ${meta.totalIncluded} (from ${meta.totalFetched} fetched).`,
    lastMA ? `Latest 14-day avg (as of ${fmtDate(lastMA.date)}): ${lastMA.value.toFixed(2)}% (window polls: ${lastMA.n}).` : `Not enough data for rolling average.`,
    meta.byPollster.length ? `Top pollsters by count: ${meta.byPollster.slice(0, 6).map(([k,v]) => `${k} (${v})`).join(", ")}.` : ""
  ].filter(Boolean).join(" ");

  document.getElementById("approvalNote").textContent = note;
}

function renderGenericBallot(points, maSeries, meta) {
  const scatterX = points.map(p => p.date);
  const scatterY = points.map(p => p.value);
  const hoverText = points.map(p =>
    `${p.pollster}<br>${fmtDate(p.date)}<br>Dem: ${p.dem.toFixed(1)}%<br>Rep: ${p.rep.toFixed(1)}%` +
    `<br>Margin (D−R): ${p.value.toFixed(1)}` +
    (p.sample_size ? `<br>n=${p.sample_size}` : "") +
    (p.url ? `<br><a href="${p.url}" target="_blank" rel="noopener">source</a>` : "")
  );

  const tracePolls = {
    type: "scatter",
    mode: "markers",
    name: "Polls (D−R)",
    x: scatterX,
    y: scatterY,
    text: hoverText,
    hovertemplate: "%{text}<extra></extra>",
    marker: { size: 9 }
  };

  const traceMA = {
    type: "scatter",
    mode: "lines",
    name: "30-day rolling avg",
    x: maSeries.map(d => d.date),
    y: maSeries.map(d => d.value),
    hovertemplate: "%{x|%Y-%m-%d}<br>Avg margin: %{y:.2f}<br>Polls in window: %{customdata}<extra></extra>",
    customdata: maSeries.map(d => d.n),
    line: { width: 3 }
  };

  const layout = {
    margin: { l: 70, r: 18, t: 10, b: 50 },
    xaxis: { title: "Poll end date", type: "date" },
    yaxis: { title: "Generic ballot margin (Dem − Rep)", zeroline: true },
    shapes: [{
      type: "line",
      xref: "paper",
      x0: 0, x1: 1,
      yref: "y",
      y0: 0, y1: 0,
      line: { width: 1, dash: "dot" }
    }],
    legend: { orientation: "h", y: 1.05, x: 0 },
    hovermode: "closest"
  };

  Plotly.newPlot("gbChart", [traceMA, tracePolls], layout, { responsive: true, displayModeBar: false });

  const lastMA = maSeries.length ? maSeries[maSeries.length - 1] : null;
  const note = [
    `Included polls: ${meta.totalIncluded} (from ${meta.totalFetched} fetched).`,
    lastMA ? `Latest 30-day avg (as of ${fmtDate(lastMA.date)}): ${lastMA.value.toFixed(2)} pts (window polls: ${lastMA.n}).` : `Not enough data for rolling average.`,
    meta.byPollster.length ? `Top pollsters by count: ${meta.byPollster.slice(0, 6).map(([k,v]) => `${k} (${v})`).join(", ")}.` : ""
  ].filter(Boolean).join(" ");

  document.getElementById("gbNote").textContent = note;
}

async function main() {
  renderPollsterList();

  const now = new Date();
  const from = new Date(now.getTime() - 400 * 24 * 60 * 60 * 1000); // ~13 months
  const fromISO = from.toISOString().slice(0,10);

  const approvalUrl = `${API_BASE}?poll_type=approval&subject=donald-trump&from_date=${fromISO}`;
  const gbUrl = `${API_BASE}?poll_type=generic-ballot&from_date=${fromISO}`;

  setStatus(
`Loading…
Approval: ${approvalUrl}
Generic ballot: ${gbUrl}
Filtering to your pollster list.`
  );

  try {
    const [approvalRaw, gbRaw] = await Promise.all([
      fetchPolls(approvalUrl),
      fetchPolls(gbUrl)
    ]);

    // ---- Approval processing ----
    const approvalFiltered = approvalRaw
      .filter(p => isAllowedPollster(p.pollster))
      .map(p => {
        const approve = getAnswerPct(p, ["Approve"]);
        const disapprove = getAnswerPct(p, ["Disapprove"]);
        const date = p.end_date ? parseDateYYYYMMDD(p.end_date) : null;
        if (date && approve != null && Number.isFinite(approve)) {
          return {
            date,
            value: Number(approve),
            approve: Number(approve),
            disapprove: disapprove != null ? Number(disapprove) : null,
            pollster: p.pollster || "Unknown",
            sample_size: p.sample_size || "",
            url: p.url || ""
          };
        }
        return null;
      })
      .filter(Boolean);

    const approvalMA = rollingMeanDaily(approvalFiltered, 14);

    // ---- Generic ballot processing ----
    const gbFiltered = gbRaw
      .filter(p => isAllowedPollster(p.pollster))
      // Keep the national generic ballot item; VoteHub uses seat_name="Generic" in the docs example.
      .filter(p => (p.seat_name == null) || String(p.seat_name).toLowerCase() === "generic")
      .map(p => {
        const dem = getAnswerPct(p, ["Dem", "Democrat"]);
        const rep = getAnswerPct(p, ["Rep", "Republican"]);
        const date = p.end_date ? parseDateYYYYMMDD(p.end_date) : null;
        if (date && dem != null && rep != null && Number.isFinite(dem) && Number.isFinite(rep)) {
          return {
            date,
            value: Number(dem) - Number(rep),
            dem: Number(dem),
            rep: Number(rep),
            pollster: p.pollster || "Unknown",
            sample_size: p.sample_size || "",
            url: p.url || ""
          };
        }
        return null;
      })
      .filter(Boolean);

    const gbMA = rollingMeanDaily(gbFiltered, 30);

    // ---- Render ----
    renderApproval(approvalFiltered, approvalMA, {
      totalFetched: approvalRaw.length,
      totalIncluded: approvalFiltered.length,
      byPollster: buildPollsterCounts(approvalFiltered)
    });

    renderGenericBallot(gbFiltered, gbMA, {
      totalFetched: gbRaw.length,
      totalIncluded: gbFiltered.length,
      byPollster: buildPollsterCounts(gbFiltered)
    });

    setStatus(`Loaded successfully.
Last refresh: ${new Date().toLocaleString()}.
(If this page looks empty, the most common culprit is “no qualifying polls in the last ~13 months” or a browser/network block.)`);

  } catch (err) {
    console.error(err);
    setStatus(`Load failed: ${err.message}\n\nIf you see this on GitHub Pages, it’s usually either:\n- a transient API outage, or\n- a CORS restriction blocking browser fetches to api.votehub.com.`);
  }
}

main();
</script>
</body>
</html>
